// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

/**
 * @title CharityPEPE - A token contract with presale and staking features
 * @notice This contract allows presale purchases and staking with rewards
 */
contract CharityPEPE {
    string public name = "CharityPEPE";
    string public symbol = "CPEPE";
    uint256 public decimals = 18;
    uint256 public totalSupply;

    uint256 private constant TRANSFER_LOCK_TIME = 1765555200; // Jan 10, 2026 - lock for buyers only
    uint256 private constant STAGE1_START = 1747843200; // March 21, 2025, 20:00 UTC
    uint256 private constant STAGE1_END = 1759180800;   // July 30, 2025, 20:00 UTC
    uint256 private constant STAGE2_START = 1759181100; // July 30, 2025, 20:05 UTC
    uint256 private constant STAGE2_END = 1765036800;   // January 1, 2026, 20:00 UTC
    uint256 private constant STAGE1_RATE = 10000;       // 1 ETH = 10,000 CPEPE
    uint256 private constant STAGE2_RATE = 5000;        // 1 ETH = 5,000 CPEPE
    address private constant USDT_ADDRESS = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    uint256 private constant USDT_RATE = 1000;          // 1 USDT = 1,000 CPEPE
    address private constant USDC_ADDRESS = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;
    uint256 private constant USDC_RATE = 1000;          // 1 USDC = 1,000 CPEPE
    uint256 private constant MAX_PURCHASE = 100 ether;
    uint256 private constant MIN_PURCHASE = 0.01 ether;
    uint256 private constant MAX_TOKENS_FOR_SALE = 5e11 * (10 ** 18); // 500 милиарда за предпродажба
    uint256 private constant MIN_STAKE_PERIOD = 6 * 30 days; // 6 месеца
    uint256 private constant MAX_MINTABLE = 1e11 * (10 ** 18); // 100 милиарда максимум за mint

    address private _owner;
    bool private _paused;
    bool private _locked;
    uint256 private _tokensSold;
    uint256 private _mintedAmount;
    mapping(address => uint256) private _lastUnstakeBlock;
    mapping(address => uint256) private _balanceOf;
    mapping(address => mapping(address => uint256)) private _allowance;
    mapping(address => uint256) private _stakedBalance;
    mapping(address => uint256) private _stakeStartTime;
    mapping(address => bool) private _isBuyer;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Mint(address indexed to, uint256 value);
    event Paused(address account);
    event Unpaused(address account);
    event Staked(address indexed user, uint256 amount);
    event Unstaked(address indexed user, uint256 amount, uint256 reward);
    event TokensPurchased(address indexed buyer, uint256 amount, string currency);
    event ETHWithdrawn(address indexed owner, uint256 amount);
    event USDTWithdrawn(address indexed owner, uint256 amount);
    event USDCWithdrawn(address indexed owner, uint256 amount);
    event EmergencyWithdraw(address indexed owner, address indexed account, uint256 amount);

    modifier onlyOwner() {
        require(msg.sender == _owner, "Not owner");
        _;
    }

    modifier whenNotPaused() {
        require(!_paused, "Paused");
        _;
    }

    modifier nonReentrant() {
        require(!_locked, "Reentrant call");
        _locked = true;
        _;
        _locked = false;
    }

    constructor() payable {
        _owner = msg.sender;
        totalSupply = 1e12 * (10 ** decimals); // 1 трилион токена
        _balanceOf[msg.sender] = totalSupply; // Всички токени при собственика
    }

    // Покупка с ETH в предпродажба
    function buyWithETH() public payable whenNotPaused nonReentrant {
        require(block.timestamp >= STAGE1_START && block.timestamp <= STAGE2_END, "Sale not active");
        require(msg.value >= MIN_PURCHASE, "Below min purchase");
        require(msg.value <= MAX_PURCHASE, "Exceeds max purchase");
        uint256 rate = (block.timestamp <= STAGE1_END) ? STAGE1_RATE : STAGE2_RATE;
        uint256 tokenAmount = msg.value * rate;
        require(_balanceOf[_owner] >= tokenAmount, "Low owner balance");
        require(_tokensSold + tokenAmount <= MAX_TOKENS_FOR_SALE, "Exceeds presale limit");
        
        _balanceOf[_owner] -= tokenAmount;
        _balanceOf[msg.sender] += tokenAmount;
        _tokensSold += tokenAmount;
        _isBuyer[msg.sender] = true;
        emit TokensPurchased(msg.sender, tokenAmount, "ETH");
    }

    // Покупка с USDT в предпродажба
    function buyWithUSDT(uint256 usdtAmount) public whenNotPaused nonReentrant {
        require(block.timestamp >= STAGE1_START && block.timestamp <= STAGE2_END, "Sale not active");
        require(usdtAmount >= MIN_PURCHASE / USDT_RATE, "Below min purchase");
        require(usdtAmount <= MAX_PURCHASE / USDT_RATE, "Exceeds max purchase");
        uint256 tokenAmount = usdtAmount * USDT_RATE;
        require(_balanceOf[_owner] >= tokenAmount, "Low owner balance");
        require(_tokensSold + tokenAmount <= MAX_TOKENS_FOR_SALE, "Exceeds presale limit");
        
        uint256 balanceBefore = IERC20(USDT_ADDRESS).balanceOf(_owner);
        require(IERC20(USDT_ADDRESS).transferFrom(msg.sender, _owner, usdtAmount), "USDT transfer failed");
        uint256 balanceAfter = IERC20(USDT_ADDRESS).balanceOf(_owner);
        require(balanceAfter >= balanceBefore + usdtAmount, "Invalid USDT transfer");

        _balanceOf[_owner] -= tokenAmount;
        _balanceOf[msg.sender] += tokenAmount;
        _tokensSold += tokenAmount;
        _isBuyer[msg.sender] = true;
        emit TokensPurchased(msg.sender, tokenAmount, "USDT");
    }

    // Покупка с USDC в предпродажба
    function buyWithUSDC(uint256 usdcAmount) public whenNotPaused nonReentrant {
        require(block.timestamp >= STAGE1_START && block.timestamp <= STAGE2_END, "Sale not active");
        require(usdcAmount >= MIN_PURCHASE / USDC_RATE, "Below min purchase");
        require(usdcAmount <= MAX_PURCHASE / USDC_RATE, "Exceeds max purchase");
        uint256 tokenAmount = usdcAmount * USDC_RATE;
        require(_balanceOf[_owner] >= tokenAmount, "Low owner balance");
        require(_tokensSold + tokenAmount <= MAX_TOKENS_FOR_SALE, "Exceeds presale limit");
        
        uint256 balanceBefore = IERC20(USDC_ADDRESS).balanceOf(_owner);
        require(IERC20(USDC_ADDRESS).transferFrom(msg.sender, _owner, usdcAmount), "USDC transfer failed");
        uint256 balanceAfter = IERC20(USDC_ADDRESS).balanceOf(_owner);
        require(balanceAfter >= balanceBefore + usdcAmount, "Invalid USDC transfer");

        _balanceOf[_owner] -= tokenAmount;
        _balanceOf[msg.sender] += tokenAmount;
        _tokensSold += tokenAmount;
        _isBuyer[msg.sender] = true;
        emit TokensPurchased(msg.sender, tokenAmount, "USDC");
    }

    // Изтегляне на ETH (само собственик)
    function withdrawETH() public onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No ETH to withdraw");
        (bool sent, ) = payable(_owner).call{value: balance}("");
        require(sent, "ETH withdrawal failed");
        emit ETHWithdrawn(_owner, balance);
    }

    // Изтегляне на USDT (само собственик)
    function withdrawUSDT() public onlyOwner nonReentrant {
        uint256 balance = IERC20(USDT_ADDRESS).balanceOf(address(this));
        require(balance > 0, "No USDT to withdraw");
        uint256 ownerBalanceBefore = IERC20(USDT_ADDRESS).balanceOf(_owner);
        require(IERC20(USDT_ADDRESS).transfer(_owner, balance), "USDT withdrawal failed");
        uint256 ownerBalanceAfter = IERC20(USDT_ADDRESS).balanceOf(_owner);
        require(ownerBalanceAfter >= ownerBalanceBefore + balance, "Invalid USDT withdrawal");
        emit USDTWithdrawn(_owner, balance);
    }

    // Изтегляне на USDC (само собственик)
    function withdrawUSDC() public onlyOwner nonReentrant {
        uint256 balance = IERC20(USDC_ADDRESS).balanceOf(address(this));
        require(balance > 0, "No USDC to withdraw");
        uint256 ownerBalanceBefore = IERC20(USDC_ADDRESS).balanceOf(_owner);
        require(IERC20(USDC_ADDRESS).transfer(_owner, balance), "USDC withdrawal failed");
        uint256 ownerBalanceAfter = IERC20(USDC_ADDRESS).balanceOf(_owner);
        require(ownerBalanceAfter >= ownerBalanceBefore + balance, "Invalid USDC withdrawal");
        emit USDCWithdrawn(_owner, balance);
    }

    function owner() external view returns (address) {
        return _owner;
    }

    function paused() external view returns (bool) {
        return _paused;
    }

    function tokensSold() external view returns (uint256) {
        return _tokensSold;
    }

    function balanceOf(address account) external view returns (uint256) {
        return _balanceOf[account];
    }

    function allowance(address account, address spender) external view returns (uint256) {
        return _allowance[account][spender];
    }

    function isBuyer(address account) external view returns (bool) {
        return _isBuyer[account];
    }

    // Mint на нови токени с лимит (само собственик)
    function mint(address to, uint256 value) public onlyOwner nonReentrant returns (bool) {
        require(to != address(0), "Invalid address");
        require(_mintedAmount + value <= MAX_MINTABLE, "Exceeds mint limit");
        totalSupply += value;
        _balanceOf[to] += value;
        _mintedAmount += value;
        emit Mint(to, value);
        return true;
    }

    function pause() public onlyOwner {
        require(!_paused, "Already paused");
        _paused = true;
        emit Paused(msg.sender);
    }

    function unpause() public onlyOwner {
        require(_paused, "Not paused");
        _paused = false;
        emit Unpaused(msg.sender);
    }

    // Спешно изтегляне на стейкнати токени (само собственик)
    function emergencyWithdraw(address account) public onlyOwner nonReentrant {
        require(_paused, "Not paused");
        require(account != address(0), "Invalid address");
        uint256 stakedAmount = _stakedBalance[account];
        if (stakedAmount > 0) {
            _stakedBalance[account] = 0;
            _balanceOf[account] += stakedAmount;
            emit Unstaked(account, stakedAmount, 0);
            emit EmergencyWithdraw(msg.sender, account, stakedAmount);
        }
    }

    // Стейкване на токени за 6 месеца
    function stake(uint256 amount) public whenNotPaused nonReentrant {
        require(amount > 0, "Zero amount");
        require(amount <= _balanceOf[msg.sender], "Low balance");

        _balanceOf[msg.sender] -= amount;
        _stakedBalance[msg.sender] += amount;
        _stakeStartTime[msg.sender] = block.timestamp;
        emit Staked(msg.sender, amount);
    }

    // Изтегляне на стейкнати токени с награда
    function unstake() public whenNotPaused nonReentrant {
        require(_stakedBalance[msg.sender] > 0, "No stake");
        require(_lastUnstakeBlock[msg.sender] != block.number, "Already unstaked this block");
        address sender = msg.sender;
        uint256 stakeTime = block.timestamp - _stakeStartTime[sender];
        require(stakeTime >= MIN_STAKE_PERIOD, "Stake period too short");

        uint256 amount = _stakedBalance[sender];
        uint256 reward = (amount * 5 * stakeTime) / (100 * 365 days); // 5% годишна награда
        require(_balanceOf[address(this)] >= reward, "Insufficient reward pool"); // Собственикът трябва да депозира токени
        _stakedBalance[sender] = 0;
        _balanceOf[address(this)] -= reward;
        _balanceOf[sender] += amount + reward;
        _lastUnstakeBlock[sender] = block.number;
        emit Unstaked(sender, amount, reward);
    }

    // Трансфер на токени без изгаряне
    function transfer(address to, uint256 amount) public whenNotPaused nonReentrant returns (bool) {
        require(to != address(0), "Invalid address");
        require(amount > 0, "Zero amount");
        address sender = msg.sender;
        require(_balanceOf[sender] >= amount, "Low balance");
        require(!_isBuyer[sender] || block.timestamp > TRANSFER_LOCK_TIME, "Buyers locked until Jan 10, 2026");

        _balanceOf[sender] -= amount;
        _balanceOf[to] += amount;
        emit Transfer(sender, to, amount);
        return true;
    }

    // Одобрение за трансфер от друг адрес
    function approve(address spender, uint256 value) public whenNotPaused returns (bool) {
        require(spender != address(0), "Invalid spender");
        require(value <= totalSupply, "Value exceeds total supply");
        _allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    // Трансфер от друг адрес без изгаряне
    function transferFrom(address from, address to, uint256 value) public whenNotPaused nonReentrant returns (bool) {
        require(from != address(0), "Invalid from");
        require(to != address(0), "Invalid to");
        require(value > 0, "Zero value");
        require(_balanceOf[from] >= value, "Low balance");
        require(_allowance[from][msg.sender] >= value, "Low allowance");
        require(!_isBuyer[from] || block.timestamp > TRANSFER_LOCK_TIME, "Buyers locked until Jan 10, 2026");

        _balanceOf[from] -= value;
        _balanceOf[to] += value;
        _allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }

    // Депозиране на токени в договора за стейкинг награди (само собственик)
    function depositRewardPool(uint256 amount) public onlyOwner nonReentrant {
        require(amount > 0, "Zero amount");
        require(_balanceOf[msg.sender] >= amount, "Low balance");
        _balanceOf[msg.sender] -= amount;
        _balanceOf[address(this)] += amount;
        emit Transfer(msg.sender, address(this), amount);
    }
}

interface IERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
}
